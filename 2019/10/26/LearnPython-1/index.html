<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    深入Python——查漏补缺(一) |
    
    CodeAsPoetry</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
<main class="content">
  <section class="outer">
  <article id="post-LearnPython-1" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h1 class="article-title" itemprop="name">
      深入Python——查漏补缺(一)
    </h1>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2019/10/26/LearnPython-1/" class="article-date">
  <time datetime="2019-10-26T05:09:40.000Z" itemprop="datePublished">2019-10-26</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python%E5%B7%A5%E7%A8%8B/">Python工程</a>
  </div>

                    </div>
                    

                        
                            
    <div class="tocbot"></div>





                                

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <ul>
<li>Python 中 dict ：key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。dict的key必须是不可变对象。这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。要保证hash的正确性，作为key的对象就不能变。<a id="more"></a>在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key</li>
<li>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。</li>
<li>对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</li>
<li>函数的参数：位置参数、默认参数、可变参数、关键字参数、命名关键字参数。参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。对于任意函数，都可以通过类似func(<em>args, *</em>kw)的形式调用它，无论它的参数是如何定义的。虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</li>
<li>解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化。</li>
<li><p>Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断</p>
</li>
<li><p>```python<br>from collections import Iterable<br>isinstance(‘abc’, Iterable)</p>
<h1 id="对list实现类似Java那样的下标循环，Python内置的enumerate函数可以把一个list变成索引-元素对"><a href="#对list实现类似Java那样的下标循环，Python内置的enumerate函数可以把一个list变成索引-元素对" class="headerlink" title="对list实现类似Java那样的下标循环，Python内置的enumerate函数可以把一个list变成索引-元素对"></a>对list实现类似Java那样的下标循环，Python内置的<code>enumerate</code>函数可以把一个list变成索引-元素对</h1><p>for i, value in enumerate([‘A’, ‘B’, ‘C’]):</p>
<pre><code>print(i, value)
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 列表生成式</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;python</span><br><span class="line">  [x * x for x in range(1, 11) if x % 2 &#x3D;&#x3D; 0]</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Python中，一边循环一边计算的机制，称为生成器：generator。创建一个generator，第一种方法很简单，只要把一个列表生成式的[ ]改成( )，就创建了一个generator，然后，使用for循环获得生成器的每个元素。定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。generator 和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator 的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代，但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration 的value中</p>
</li>
<li><p>可以直接作用于for循环的对象统称为可迭代对象：Iterable，可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。Python的for循环本质上就是通过不断调用next()函数实现的。</p>
</li>
<li><p>函数本身也可以赋值给变量，即：变量可以指向函数；函数名其实就是指向函数的变量；既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数，函数式编程就是指这种高度抽象的编程范式。</p>
</li>
<li><p>Python内建了map( )和reduce( )函数。map( )函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。</p>
</li>
<li><p>filter( )接收一个函数和一个序列。filter( )把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。filter( )的作用是从一个序列中筛出符合条件的元素。由于filter( )使用了惰性计算，所以只有在取filter( )结果的时候，才会真正筛选并每次返回下一个筛出的元素。</p>
</li>
<li><p>sorted( )函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。要进行反向排序，不必改动key函数，可以传入第三个参数reverse = True</p>
</li>
<li><p>在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum 返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。</p>
</li>
<li><p>在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。匿名函数 lambda x: x * x，关键字lambda表示匿名函数，冒号前面的x表示函数参数。匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。</p>
</li>
<li><p>在代码运行期间动态增加功能的方式，称之为“装饰器”(Decorator) 。本质上，decorator就是一个返回函数的高阶函数，借助Python的@语法，把decorator置于函数的定义处。如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。需要把原始函数的<strong>name</strong>等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。Python内置的functools.wraps就是干这个事的。</p>
</li>
<li><p>偏函数，functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。创建偏函数时，实际上可以接收函数对象、<em>args和*</em>kw这3个参数。当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</p>
</li>
<li><p>当试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中。要添加自己的搜索目录，有两种方法：一是直接修改sys.path，添加要搜索的目录，这种方法是在运行时修改，运行结束后失效；第二种方法是设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</p>
</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2019/10/26/LearnPython-1/" data-id="ck81kmz2j000kky4pacsi3krl" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python%E5%BB%96%E9%9B%AA%E5%B3%B0%E3%80%81Python%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/" rel="tag">Python廖雪峰、Python查漏补缺</a></li></ul>

                                    </footer>

    </div>

    
        
  <nav class="article-nav">
    
      <a href="/2019/10/29/LearnPython-2/" class="article-nav-link">
        <strong class="article-nav-caption">Newer</strong>
        <div class="article-nav-title">
          
            深入Python——查漏补缺(二)
          
        </div>
      </a>
    
    
      <a href="/2019/10/17/ALBERT/" class="article-nav-link">
        <strong class="article-nav-caption">Older</strong>
        <div class="article-nav-title">ALBERT A Lite BERT for Self-supervised Learning of Language Representations</div>
      </a>
    
  </nav>


            

                
                    
                        
                            

</article>
</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 CodeAsPoetry</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean" target="_blank" rel="noopener">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="CodeAsPoetry"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>

<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




  
<script src="/js/tocbot.min.js"></script>

  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>



<script src="/js/ocean.js"></script>


</body>
</html>